package main

import (
	"bufio"
	"context"
	"fmt"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/chromedp/chromedp"
)

const maxSnippets = 5 // Maximum snippets to display per site

var supportedLanguages = []string{"Java", "Python", "C/C++"} // Predefined supported languages

/*
generateQuery()

Generates a search query string based on user input, formatted for search engines.

Parameters:
  - functionName: The name of the function being searched for (string).
  - description: A brief description of the function (string).
  - language: The programming language of interest (string).
  - site: The website to search on (string).

Returns:
  - A formatted search query string (string).
*/
func generateQuery(functionName, description, language, site string) string {
	query := fmt.Sprintf("%s function %s", functionName, description)
	if language != "" {
		query = fmt.Sprintf("%s %s example site:%s", query, language, site)
	} else {
		query = fmt.Sprintf("%s example site:%s", query, site)
	}
	return query
}

/*
searchWeb()

Performs a web search using the provided query on the specified website.

Parameters:
  - ctx: A context for managing browser sessions (context.Context).
  - query: The search query string, generated by generateQuery() (string).
  - site: The website to perform the search on (string).

Returns:
  - The first URL found from the search results (string).
  - An error, if any occurs during the search (error).
*/
func searchWeb(ctx context.Context, query, site string) (string, error) {
	var firstLink string

	fmt.Printf("Searching %s...\n", site)
	err := chromedp.Run(ctx,
		chromedp.Navigate("https://www.google.com"),
		chromedp.WaitVisible(`textarea[aria-label="Search"]`, chromedp.ByQuery),
		chromedp.SendKeys(`textarea[aria-label="Search"]`, query+"\n", chromedp.ByQuery),
		chromedp.WaitVisible(`#search a[href*="`+site+`"]`, chromedp.ByQuery),
		chromedp.AttributeValue(`#search a[href*="`+site+`"]`, "href", &firstLink, nil, chromedp.ByQuery),
	)
	if err != nil {
		return "", fmt.Errorf("failed to perform search: %w", err)
	}
	if firstLink == "" {
		return "", fmt.Errorf("no link found in search results")
	}
	return firstLink, nil
}

/*
extractCodeSnippets()

Scraps the code snippets found on a webpage from a given URL.
The code snippets are scraped by parsing through the webpage's HTML elements and extracting the contents of
the types of elements that are known to have code snippets.

Parameters:
  - ctx: A context for managing browser sessions (context.Context).
  - url: The URL of the webpage to scrape snippets from (string).

Returns:
  - A list of extracted code snippets (slice of strings).
  - An error, if any occurs during extraction (error).
*/
func extractCodeSnippets(ctx context.Context, url string) ([]string, error) {
	var snippets []string

	fmt.Printf("Navigating to %s...\n", url)
	err := chromedp.Run(ctx,
		chromedp.Navigate(url),
		chromedp.WaitVisible(`body`, chromedp.ByQuery),
		chromedp.Evaluate(`Array.from(document.querySelectorAll('pre, code, .code-container *, .w3-code, .example *'))
			.filter(el => el.innerText.length > 50)
			.map(el => el.innerText)`, &snippets),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to extract code snippets: %w", err)
	}

	return snippets, nil
}

/*
detectLanguage()

Identifies the programming language of a code snippet by checking for specific keywords and patterns.

Parameters:
  - snippet: A single code snippet as a string.

Returns:
  - The detected programming language as a string ("Python", "Java", "C/C++", or "Unknown").
*/
func detectLanguage(snippet string) string {
	lowerSnippet := strings.ToLower(snippet)

	switch {
	case strings.Contains(lowerSnippet, "def ") && !(strings.Contains(lowerSnippet, "typedef")) ||
		(strings.Contains(lowerSnippet, "class ") && strings.Contains(lowerSnippet, ":")) && (strings.Contains(lowerSnippet, "def ")) && !(strings.Contains(lowerSnippet, "typedef")):
		return "Python"
	case strings.Contains(lowerSnippet, "public static void main") && !(strings.Contains(lowerSnippet, "#include")) && !(strings.Contains(lowerSnippet, "typedef")) ||
		(strings.Contains(lowerSnippet, "class ") && strings.Contains(lowerSnippet, "{") && strings.Contains(lowerSnippet, "public")) && !(strings.Contains(lowerSnippet, "#include")) && !(strings.Contains(lowerSnippet, "typedef")) ||
		strings.Contains(lowerSnippet, "import java") && !(strings.Contains(lowerSnippet, "#include")) && !(strings.Contains(lowerSnippet, "typedef")):
		return "Java"
	case strings.Contains(lowerSnippet, "#include") ||
		strings.Contains(lowerSnippet, "int main") ||
		strings.Contains(lowerSnippet, "printf(") ||
		strings.Contains(lowerSnippet, "typedef"):
		return "C/C++"
	default:
		return "Unknown"
	}
}

/*
filterRelevantSnippets()

Filters a list of code snippets to include only those matching the user's selected language.
Also separates snippets written in other languages.

Parameters:
  - snippets: A list of code snippets extracted from a webpage (slice of strings).
  - language: The target programming language selected by the user (string).

Returns:
  - A list of filtered snippets matching the selected language (slice of strings).
  - A list of snippets written in other languages (slice of strings).
*/
func filterRelevantSnippets(snippets []string, language string) ([]string, []string) {
	var filtered []string
	var otherLanguages []string
	seen := make(map[string]bool)

	for _, snippet := range snippets {
		if len(strings.TrimSpace(snippet)) < 50 || seen[snippet] {
			continue
		}
		seen[snippet] = true

		detectedLang := detectLanguage(snippet)
		if detectedLang == language {
			filtered = append(filtered, snippet)
		} else {
			otherLanguages = append(otherLanguages, snippet)
		}
	}

	if len(filtered) > maxSnippets {
		filtered = filtered[:maxSnippets]
	}
	if len(otherLanguages) > maxSnippets {
		otherLanguages = otherLanguages[:maxSnippets]
	}

	return filtered, otherLanguages
}

/*
getUserLanguageChoice()

Prompts the user to select a programming language from predefined options.

Returns:
  - The selected programming language as a string.
*/
func getUserLanguageChoice() string {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("Select the programming language:")
	for i, lang := range supportedLanguages {
		fmt.Printf("%d: %s\n", i+1, lang)
	}

	for {
		fmt.Print("Enter your choice: ")
		choice, _ := reader.ReadString('\n')
		choice = strings.TrimSpace(choice)

		if choiceNum, err := strconv.Atoi(choice); err == nil && choiceNum >= 1 && choiceNum <= len(supportedLanguages) {
			return supportedLanguages[choiceNum-1]
		}
		fmt.Println("Invalid choice. Please select a valid number.")
	}
}

/*
selectSites()

Prompts the user to select one or more websites to search for code snippets.

Returns:
  - A list of selected websites as strings (slice of strings).
*/
func selectSites() []string {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("\nChoose the website(s) to search:")
	fmt.Println("1: StackOverflow")
	fmt.Println("2: GeeksforGeeks")
	fmt.Println("3: W3Schools")
	fmt.Println("4: Tutorialspoint")
	fmt.Println("5: All")
	fmt.Print("\nEnter your choice: ")
	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		return []string{"stackoverflow.com"}
	case "2":
		return []string{"geeksforgeeks.org"}
	case "3":
		return []string{"w3schools.com"}
	case "4":
		return []string{"tutorialspoint.com"}
	case "5":
		return []string{"stackoverflow.com", "geeksforgeeks.org", "w3schools.com", "tutorialspoint.com"}
	default:
		fmt.Println("Invalid choice. Exiting.")
		os.Exit(1)
	}
	return nil
}

/*
processSite()

Handles the scraping process for a specific website, including searching, extracting, and filtering snippets.

Parameters:
  - site: The name of the website to process (string).
  - functionName: The function name to search for (string).
  - description: A brief description of the function (string).
  - language: The target programming language (string).
*/
func processSite(site, functionName, description, language string) {
	siteCtx, cancel := chromedp.NewContext(context.Background())
	defer cancel()

	ctxWithTimeout, timeoutCancel := context.WithTimeout(siteCtx, 60*time.Second)
	defer timeoutCancel()

	query := generateQuery(functionName, description, language, site)
	fmt.Printf("\nüîç Searching on %s...\n", site)

	link, err := searchWeb(ctxWithTimeout, query, site)
	if err != nil {
		fmt.Printf("‚ùå Error during search on %s: %v\n", site, err)
		return
	}
	fmt.Printf("‚úîÔ∏è  Found link: %s\n", link)

	snippets, err := extractCodeSnippets(ctxWithTimeout, link)
	if err != nil {
		fmt.Printf("‚ùå Error extracting snippets from %s: %v\n", site, err)
		return
	}

	filteredSnippets, otherLanguages := filterRelevantSnippets(snippets, language)

	// Remove Unknown"snippets from otherLanguages
	nonUnknownOthers := []string{}
	for _, snippet := range otherLanguages {
		if detectLanguage(snippet) != "Unknown" {
			nonUnknownOthers = append(nonUnknownOthers, snippet)
		}
	}

	divider := strings.Repeat("=", 50)

	// Print filtered snippets matching the selected language
	fmt.Println(divider)
	if len(filteredSnippets) > 0 {
		fmt.Printf("\nüåü Relevant Snippets Found on %s:\n", site)
		fmt.Println(divider)
		for i, snippet := range filteredSnippets {
			fmt.Printf("\nSnippet %d (%s):\n", i+1, detectLanguage(snippet))
			fmt.Println(divider)
			fmt.Println(snippet)
			fmt.Println(divider)
		}
	} else if len(nonUnknownOthers) > 0 {
		// Print snippets in other detected languages
		fmt.Printf("\n‚ö†Ô∏è  No snippets matched your requested language on %s. Showing other languages:\n", site)
		fmt.Println(divider)
		for i, snippet := range nonUnknownOthers {
			fmt.Printf("\nSnippet %d (%s):\n", i+1, detectLanguage(snippet))
			fmt.Println(divider)
			fmt.Println(snippet)
			fmt.Println(divider)
		}
	} else {
		// If no relevant snippets are found
		fmt.Printf("\n‚ùå No relevant snippets found on %s\n", site)
		fmt.Println(divider)
	}
}

/*
main()

The entry point for the program. Orchestrates user input, site selection, and concurrent snippet processing.
*/func main() {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("###############################################")
	fmt.Println("#          CODE SNIPPET SEARCH TOOL           #")
	fmt.Println("###############################################\n")

	fmt.Print("Enter the function name (optional): ")
	functionName, _ := reader.ReadString('\n')
	functionName = strings.TrimSpace(functionName)

	fmt.Print("\nEnter a brief description of the function: ")
	description, _ := reader.ReadString('\n')
	description = strings.TrimSpace(description)

	language := getUserLanguageChoice()
	sites := selectSites()

	fmt.Println("\n###############################################")
	fmt.Println("#           SEARCHING FOR SNIPPETS            #")
	fmt.Println("###############################################")

	var wg sync.WaitGroup
	for _, site := range sites {
		wg.Add(1)
		go func(site string) {
			defer wg.Done()
			processSite(site, functionName, description, language)
		}(site)
	}
	wg.Wait()

	fmt.Println("\n###############################################")
	fmt.Println("#                 SEARCH COMPLETE             #")
	fmt.Println("###############################################")
}
